# הסבר מפורט על נוסחת SSMS האופטימלית

## סקירה כללית

הנוסחה האופטימלית ל-SSMS שומרת על היחסים המקוריים של מפת החום בצורה מושלמת, תוך טיפול ב-heatmaps sparse. הנוסחה רציפה לחלוטין (ללא תנאים או קפיצות) ופשוטה מאוד.

---

## מבנה הנוסחה (4 שלבים)

### שלב 1: נרמול מפת החום

```python
H_max = heatmap.max()
if H_max > eps:
    H_norm = heatmap / H_max
else:
    H_norm = heatmap
```

**מה זה עושה:**
- מנרמל את כל הערכים במפת החום לטווח [0, 1]
- מחלק כל ערך בערך המקסימלי

**למה זה טוב:**
- מבטיח שכל הערכים באותו טווח
- שומר על היחסים המקוריים: אם `H1/H2 = r`, אז `H_norm1/H_norm2 = r`

**דוגמה:**
```
H = [0.8, 0.6, 0.4, 0.2, 0.0]
H_max = 0.8
H_norm = [1.0, 0.75, 0.5, 0.25, 0.0]

יחסים:
- H: 0.6/0.8 = 0.75 ✓
- H_norm: 0.75/1.0 = 0.75 ✓ (נשמר!)
```

---

### שלב 2: מיפוי ליניארי (שימור יחסים מושלם)

```python
mask_base = H_norm
```

**מה זה עושה:**
- משתמש בפונקציה ליניארית (ללא שינוי)
- `mask_base` זהה ל-`H_norm`

**למה זה טוב:**
- שומר על יחסים מושלמים: אם `H1/H2 = r`, אז `mask1/mask2 = r` (בדיוק!)
- פשוט ויעיל (ללא חישובים מורכבים)

**דוגמה:**
```
H_norm = [1.0, 0.8, 0.5, 0.1, 0.0]
mask_base = [1.0, 0.8, 0.5, 0.1, 0.0]

יחסים:
- H_norm: 0.8/1.0 = 0.8 ✓
- mask_base: 0.8/1.0 = 0.8 ✓ (מושלם!)
```

**למה לא להשתמש בחזקה?**
אם נשתמש ב-`mask_base = H_norm^1.1`:
```
mask_base = [1.0, 0.798, 0.49, 0.098, 0.0]
יחסים: 0.798/1.0 = 0.798 (לא 0.8! שגיאה של 0.25%)
```
הליניארי שומר על יחסים מושלמים!

---

### שלב 3: Floor ל-heatmaps sparse

```python
# 3a. חישוב sparsity ratio
sparsity_ratio = S / N  # S = sum of all values, N = number of pixels

# 3b. חישוב floor value (רציף, ללא תנאים)
floor_sigmoid = 1.0 / (1.0 + np.exp(25.0 * (sparsity_ratio - 0.12)))
min_floor = 0.15 * floor_sigmoid

# 3c. יישום floor (רק לערכים אפסיים)
k = 100.0
floor_transition = np.exp(-k * mask_base)
mask = mask_base + min_floor * floor_transition
```

#### 3a. חישוב Sparsity Ratio

**מה זה עושה:**
- `sparsity_ratio = S/N` כאשר:
  - `S` = סכום כל הערכים במפת החום
  - `N` = מספר הפיקסלים

**למה זה טוב:**
- מודד כמה sparse ה-heatmap:
  - `sparsity_ratio = 0` → sparse מאוד (רק חלק קטן חשוב)
  - `sparsity_ratio = 1` → לא sparse (כל הפיקסלים חשובים באותה מידה)

**דוגמה:**
```
H = [1.0, 0.0, 0.0, 0.0, 0.0]
S = 1.0, N = 5
sparsity_ratio = 1.0/5 = 0.2 (sparse)
```

#### 3b. חישוב Floor Value (Sigmoid)

**מה זה עושה:**
- משתמש ב-sigmoid function ליצירת מעבר רציף
- `floor_sigmoid = 1` כש-sparse (low ratio), `0` כשלא sparse (high ratio)

**למה זה טוב:**
- רציף לחלוטין (ללא תנאים)
- מתאים את ה-floor לפי ה-sparsity

**דוגמה:**
```
sparsity_ratio = 0.05 (sparse מאוד)
floor_sigmoid = 1/(1+exp(25*(0.05-0.12))) ≈ 1.0
min_floor = 0.15 * 1.0 = 0.15 (15% floor)

sparsity_ratio = 0.5 (לא sparse)
floor_sigmoid = 1/(1+exp(25*(0.5-0.12))) ≈ 0.0
min_floor = 0.15 * 0.0 = 0.0 (ללא floor)
```

#### 3c. יישום Floor (Exponential Decay)

**מה זה עושה:**
- `floor_transition = exp(-k * mask_base)`
- כאשר `k = 100.0` (decay rate גבוה)

**למה זה טוב:**
- משפיע רק על ערכים אפסיים/נמוכים מאוד
- לא משנה יחסים של ערכים גבוהים

**איך זה עובד:**
```
mask_base = [1.0, 0.8, 0.5, 0.1, 0.0]
floor_transition = exp(-100 * mask_base):
- mask_base=1.0: exp(-100) ≈ 0.0 ✓ (ללא floor)
- mask_base=0.8: exp(-80) ≈ 0.0 ✓ (ללא floor)
- mask_base=0.5: exp(-50) ≈ 0.0 ✓ (ללא floor)
- mask_base=0.1: exp(-10) ≈ 0.0 ✓ (ללא floor)
- mask_base=0.0: exp(0) = 1.0 ✓ (floor מלא!)

mask = mask_base + 0.15 * floor_transition:
- [1.0, 0.8, 0.5, 0.1, 0.15]
```

**למה זה טוב:**
- ה-floor משפיע רק על ערכים אפסיים
- יחסים של ערכים גבוהים נשמרים מושלם!

---

### שלב 4: Clip ל-[0, 1]

```python
mask = np.clip(mask, 0, 1)
```

**מה זה עושה:**
- מבטיח שכל ערכי ה-mask בטווח [0, 1]

**למה זה טוב:**
- מבטיח שהמיסוך תקין (לא שלילי, לא מעל 1)

---

## דוגמאות מספריות מלאות

### דוגמה 1: Heatmap רגיל

```
H = [1.0, 0.8, 0.5, 0.1, 0.0]

שלב 1: נרמול
H_norm = [1.0, 0.8, 0.5, 0.1, 0.0]

שלב 2: ליניארי
mask_base = [1.0, 0.8, 0.5, 0.1, 0.0]

שלב 3: Floor
sparsity_ratio = 2.4/5 = 0.48 (לא sparse)
floor_sigmoid ≈ 0.0
min_floor ≈ 0.0
floor_transition = [0.0, 0.0, 0.0, 0.0, 1.0]
mask = [1.0, 0.8, 0.5, 0.1, 0.15]

שלב 4: Clip
mask = [1.0, 0.8, 0.5, 0.1, 0.15]

יחסים:
- H: 0.8/1.0 = 0.8 → mask: 0.8/1.0 = 0.8 ✓ (מושלם!)
- H: 0.5/1.0 = 0.5 → mask: 0.5/1.0 = 0.5 ✓ (מושלם!)
```

### דוגמה 2: Heatmap sparse מאוד

```
H = [1.0, 0.0, 0.0, 0.0, 0.0]

שלב 1: נרמול
H_norm = [1.0, 0.0, 0.0, 0.0, 0.0]

שלב 2: ליניארי
mask_base = [1.0, 0.0, 0.0, 0.0, 0.0]

שלב 3: Floor
sparsity_ratio = 1.0/5 = 0.2 (sparse)
floor_sigmoid ≈ 1.0
min_floor ≈ 0.15
floor_transition = [0.0, 1.0, 1.0, 1.0, 1.0]
mask = [1.0, 0.15, 0.15, 0.15, 0.15]

שלב 4: Clip
mask = [1.0, 0.15, 0.15, 0.15, 0.15]

תוצאה: החלק החשוב (1.0) נשמר, החלקים הלא חשובים (0.0) מקבלים 15% מיסוך
```

---

## יתרונות הנוסחה

1. **שימור יחסים מושלם**: `H1/H2 = mask1/mask2` (בדיוק!)
2. **רציפה לחלוטין**: ללא תנאים, ללא קפיצות
3. **מטפלת ב-sparse**: floor מינימלי ל-heatmaps sparse
4. **פשוטה**: רק 4 שלבים
5. **יעילה**: ללא חישובים מורכבים

---

## השוואה לנוסחאות קודמות

### נוסחה קודמת (עם power_factor):
```
mask_base = H_norm^1.1
יחסים: 0.8^1.1 / 1.0^1.1 = 0.798 (שגיאה של 0.25%)
```

### נוסחה חדשה (ליניארי):
```
mask_base = H_norm
יחסים: 0.8 / 1.0 = 0.8 (מושלם!)
```

---

## סיכום

הנוסחה האופטימלית:
1. מנרמלת את מפת החום
2. משתמשת בפונקציה ליניארית (שומרת יחסים)
3. מוסיפה floor רק לערכים אפסיים (מטפלת ב-sparse)
4. קוצצת ל-[0, 1]

זה הכל! פשוט, יעיל, ושומר על יחסים מושלמים.




